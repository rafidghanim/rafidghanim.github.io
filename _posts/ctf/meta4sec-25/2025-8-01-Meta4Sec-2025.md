---
layout: post
title: "Meta4Sec 2025‚Äì Crypto"
date: 2025-08-02
categories: [National Event, Meta4Sec 2025,ctf]
tags: [crypto]
toc: true
---

<p align="left"> <img src="/assets/img/meta4sec.jpeg" alt="logo" width="300"></p>

# Meta4Sec 2025 ‚Äì Crypto Writeup

> Writeup from the **Meta4Sec CTF** Cryptography challenge that I‚Äôve worked on

Thank you for taking the time and effort to solve the cryptography challenge I created. I truly appreciate the thought, strategies, and dedication you put into working through it. I hope this challenge provided you with valuable experience and insight into the world of cryptography. üíªüîê

---

## üîê Crypto

### üîπ Challenge: 0
- **Description**: -
- **Attachments**: [chall_0.zip](/assets/files/meta4sec/chall_0.zip)
- **Solution Steps**:

#### üß© Challenge Overview

We are provided with a zip archive. After extracting it, we get the following files:

```
flag.txt  output_test.txt  readme.md  test.txt
```

##### üìÑ readme.md

```md
A mysterious message has been intercepted, and according to analysts, it appears to be encrypted with an unusual twist on a traditional cipher.

Luckily, we have a sample of both the plaintext and its corresponding ciphertext, which seems to be encrypted using the same method as the flag.

Your task is to:
1. Identify the encryption pattern by comparing the known plaintext and ciphertext.
2. Use this pattern to decrypt the flag in `flag.txt`.

===[ Files ]===

- test.txt            # known plaintext
- output_test.txt     # corresponding ciphertext
- flag.txt            # encrypted flag

===[ Objective ]===

Retrieve the original flag from `flag.txt`.

Flag format: `Meta4Sec{...}`

Brute-forcing isn't required to solve this, but you‚Äôre welcome to try. A logical approach and familiarity with classic ciphers will be more effective.

Good luck!
```

---

#### üéØ Task Summary

Based on the information in `readme.md`, the main objective is to analyze the encryption used in `test.txt` and `output_test.txt`, and then apply the same logic to decrypt `flag.txt`.

---

#### üîç Sample Analysis

##### From `output_test.txt`:
```
Sheajra Shaal suat bkeunt einskpri taeurt dmaal sheajra dna mhais saendaehr ahdaal einskpri mneankgagnu aalmgtoir
```

##### From `test.txt`:
```
Sejarah Salah satu bentuk enkripsi tertua dalam sejarah dan masih sederhana adalah enkripsi menggunakan algoritma
```

Let‚Äôs examine the encryption of the word `Sejarah` ~> `Sheajra`.

| Index | Original | Encrypted |
|-------|----------|-----------|
| 0     | S        | S         |
| 1     | e        | h         |
| 2     | j        | e         |
| 3     | a        | a         |
| 4     | r        | j         |
| 5     | a        | r         |
| 6     | h        | a         |

We observe the following transformation:
- index[0] stays the same ~> `S`
- index[1] becomes index[6]
- index[2] becomes index[1]
- index[3] becomes index[5]
- index[4] becomes index[2]
- index[5] becomes index[4]
- index[6] becomes index[3]

`bentuk` ~> `bkeunt`

| Index | Original | Encrypted |
|-------|----------|-----------|
| 0     | b        | b         |
| 1     | e        | k         |
| 2     | n        | e         |
| 3     | t        | u         |
| 4     | u        | n         |
| 5     | k        | t         |

- index[0] stays the same ‚Üí `b`
- index[1] becomes index[5]
- index[2] becomes index[1]
- index[3] becomes index[5]
- index[4] becomes index[2]
- index[5] becomes index[4]

This suggests a fixed permutation pattern
This insight gives us a solid base to reverse the process and decrypt the flag.

> solver.py

```python
 encode(s:str) -> str:
    result = []
    n = len(s)
    for i in range(n // 2):
        result.append(s[i])
        result.append(s[n - 1 - i])
    if n % 2 == 1:
        result.append(s[n // 2])
    return ''.join(result)

def decode(s:str) -> str:
    n = len(s)
    result = [''] * n
    left = 0
    right = n - 1
    idx = 0
    for i in range(n // 2):
        result[left] = s[idx]
        result[right] = s[idx + 1]
        idx += 2
        left += 1
        right -= 1
    if n % 2 == 1:
        result[left] = s[idx]
    return ''.join(result)


with open('flag.txt','r') as f:
    enc = f.read().split()
decrypted = []
for j in enc:
    decrypted.append(decode(j))

print(' '.join(decrypted))
```

- **Flag**: `Meta4Sec{sajjjaddddkunnnn_absoluteeee_cineemaaaaaa_202cb962ac}`

---

### üîπ Challenge: 1
- **Description**: -
- **Attachments**:  [chall_zip](/assets/files/meta4sec/chall.zip)
- **Solution Steps**:


#### üîê Overview

This challenge script implements RSA encryption using a custom large-prime generation method. The encryption process introduces several cryptographic weaknesses that make the ciphertext recoverable.

---

#### üß™ Prime Generation Logic

```python
def generate_large_prime_product():
    p = getPrime(512)
    n = 1
    phi = 1
    primes = []

    while True:
        primes.append(p)
        n *= p
        phi *= (p - 1)
        if n.bit_length() >= 8192:
            break
        p = nextprime(nextprime(p))

    return n, primes, phi, p
```

- This function generates multiple **512-bit primes** and multiplies them until the result (`n`) is at least **8192 bits** long.
- The primes are generated using `nextprime(nextprime(p))`, meaning each new prime is **very close** to the previous one.
- Because these primes are closely spaced, the modulus `n` becomes vulnerable to **root-based factorization techniques** and then go back into previous prime until the result of  gcd prime and N less than 512 bit length.

---

#### üß¨ RSA Key Generation Logic

```python
def get_valid_prime_update(n):
    return nextprime(n)

def generate_rsa_keys(p, e=65537):
    q = getPrime(16)
    n = p * q
    phi = (p - 1) * (q - 1)
    d = inverse(e, phi)
    private_key = RSA.construct((n, e, d, p, q))
    public_key = private_key.publickey()
    return private_key, public_key
```

- After the initial modulus is constructed, the program updates the prime using `nextprime(n)` and treats this as the new `p`.
- A new small prime `q` is generated using `getPrime(16)`, which results in a **16-bit** value.
- Because `q` is so small, it can be **brute-forced easily** by trying all values in the range [1, 65536].

---

#### ‚ö†Ô∏è Vulnerability Summary

- The first modulus `n` is built from many closely spaced 512-bit primes. These can be **factored** using numerical root techniques since the primes are near each other.
- The updated prime `p` is just `nextprime(n)`, which is **predictable**.
- The second prime `q` is only 16 bits, making it **trivial to brute-force**.
- These combined weaknesses make it possible to reconstruct the **private RSA key** and recover the plaintext from `public.pem` and the encrypted file.

---

#### üß© Exploitation Strategy

1. Factor the initial 8192-bit modulus using numerical methods that exploit closely spaced primes.
2. Compute `p = nextprime(n)` as used in the second phase.
3. Brute-force all possible 16-bit `q` values (‚â§ 65536) to find the correct one.
4. Rebuild the full private key using `p` and `q`.
5. Decrypt the encrypted chunks and recover the original ciphertext.

---


#### üìú Solver

```python
# === IMPORTS ===
import base64
import time
from math import gcd

from sympy import nextprime
from gmpy2 import iroot
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Util.number import (
    getPrime, inverse, bytes_to_long, long_to_bytes, isPrime
)

# === HELPER FUNCTIONS ===

def prevprime(n):
    """Find previous prime before n."""
    n -= 1
    while n > 1:
        if isPrime(n):
            return n
        n -= 1
    return None  # Shouldn't happen for n > 2

def generate_large_prime_product(p, n_candidate, e=65537):
    """Generate RSA modulus and private exponent from base prime `p`."""
    n = 1
    phi = 1
    primes = []

    while True:
        primes.append(p)
        n *= p
        phi *= (p - 1)
        if n.bit_length() >= 8192:
            break
        p = nextprime(nextprime(p))

    if n in n_candidate:
        d = inverse(e, phi)
        return n, e, d

    return None, None, None

def decrypt(p, q, encrypted, e=65537):
    """Decrypt ciphertext using reconstructed RSA private key."""
    n = p * q
    phi = (p - 1) * (q - 1)
    d = inverse(e, phi)

    private_key = RSA.construct((n, e, d, p, q))
    public_key = private_key.publickey()

    cipher_decrypt = PKCS1_OAEP.new(private_key)

    key_size = public_key.size_in_bytes()
    chunk_size = key_size  # ciphertext chunk size

    decrypted_data = b""
    for i in range(0, len(encrypted), chunk_size):
        chunk = encrypted[i:i + chunk_size]
        decrypted_data += cipher_decrypt.decrypt(chunk)

    return decrypted_data

def find_factor_1(x):
    """Brute-force factor using small values."""
    for i in range(32767, 65537):
        if gcd(x, i) < 3000:
            continue
        p = i
        q = x // i
        return p, q

# === MAIN PROGRAM ===

if __name__ == "__main__":
    # Load public key
    with open("public.pem", "rb") as f:
        public_key = RSA.import_key(f.read())

    # Load encrypted file
    with open("encrypted", "rb") as f:
        ct = f.read()

    n = public_key.n
    e = public_key.e

    # Factor n (rough guess)
    p, q = find_factor_1(n)

    # Decrypt with small p and q
    ct_2 = bytes_to_long(decrypt(p, q, ct))

    # Build candidate list near q
    n_candidate = [q - i for i in range(100000)]

    # Try root extraction to find 512-bit base
    to_pr = []
    for j in range(1, 50):
        n_pr = iroot(q, j)[0]
        if n_pr.bit_length() == 512:
            to_pr.append(n_pr)

    prim = to_pr[0]
    sav = []

    # Start prime search
    start_time = time.time()
    while True:
        if time.time() - start_time > 10:
            break

        if isPrime(prim):
            found = False
            for N in n_candidate:
                if gcd(prim, N) != 1:
                    if prim not in sav:
                        sav.append(prim)
                        print(f"[+] Found: {prim}")
                    found = True
                    break
            prim = prevprime(prevprime(prim)) if found else prevprime(prim)
        else:
            prim = prevprime(prim)

    print("Saved primes:", sav)
    print("Last checked prime:", prim)

    # Generate RSA params using last saved prime
    f_pr = sav[-1]
    n, e, d = generate_large_prime_product(f_pr, n_candidate)

    # Decrypt the actual flag
    if n and d:
        flag = long_to_bytes(pow(ct_2, d, n))
        print(flag.decode())
    else:
        print("Failed to generate valid RSA parameters.")
```
#### ‚úÖ Conclusion

This encryption mechanism is flawed due to:

- Use of many **closely spaced primes** to generate a large modulus.
- Use of a **predictable updated prime** via `nextprime(n)`.
- Use of a **weak 16-bit prime** for RSA key generation.

These flaws break RSA‚Äôs security assumptions and allow full decryption of the encrypted flag.

---


- **Flag**: `Meta4Sec{l0r3m_1p5um_d0l0r_517_4m37_de6e5}`

---


---

> _"Capture The Flag is not just a game. It‚Äôs a journey to mastering cybersecurity."_  
> #HappyHacking üîê
